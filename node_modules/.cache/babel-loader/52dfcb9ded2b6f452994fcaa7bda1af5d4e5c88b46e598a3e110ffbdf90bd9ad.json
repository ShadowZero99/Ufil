{"ast":null,"code":"'use strict';\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nvar util = require('util');\nvar _require = require('triple-beam'),\n  SPLAT = _require.SPLAT;\n/**\n * Captures the number of format (i.e. %s strings) in a given string.\n * Based on `util.format`, see Node.js source:\n * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230\n * @type {RegExp}\n */\n\nvar formatRegExp = /%[scdjifoO%]/g;\n/**\n * Captures the number of escaped % signs in a format string (i.e. %s strings).\n * @type {RegExp}\n */\n\nvar escapedPercent = /%%/g;\nvar Splatter = /*#__PURE__*/\nfunction () {\n  function Splatter(opts) {\n    _classCallCheck(this, Splatter);\n    this.options = opts;\n  }\n  /**\n     * Check to see if tokens <= splat.length, assign { splat, meta } into the\n     * `info` accordingly, and write to this instance.\n     *\n     * @param  {Info} info Logform info message.\n     * @param  {String[]} tokens Set of string interpolation tokens.\n     * @returns {Info} Modified info message\n     * @private\n     */\n\n  _createClass(Splatter, [{\n    key: \"_splat\",\n    value: function _splat(info, tokens) {\n      var msg = info.message;\n      var splat = info[SPLAT] || info.splat || [];\n      var percents = msg.match(escapedPercent);\n      var escapes = percents && percents.length || 0; // The expected splat is the number of tokens minus the number of escapes\n      // e.g.\n      // - { expectedSplat: 3 } '%d %s %j'\n      // - { expectedSplat: 5 } '[%s] %d%% %d%% %s %j'\n      //\n      // Any \"meta\" will be arugments in addition to the expected splat size\n      // regardless of type. e.g.\n      //\n      // logger.log('info', '%d%% %s %j', 100, 'wow', { such: 'js' }, { thisIsMeta: true });\n      // would result in splat of four (4), but only three (3) are expected. Therefore:\n      //\n      // extraSplat = 3 - 4 = -1\n      // metas = [100, 'wow', { such: 'js' }, { thisIsMeta: true }].splice(-1, -1 * -1);\n      // splat = [100, 'wow', { such: 'js' }]\n\n      var expectedSplat = tokens.length - escapes;\n      var extraSplat = expectedSplat - splat.length;\n      var metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : []; // Now that { splat } has been separated from any potential { meta }. we\n      // can assign this to the `info` object and write it to our format stream.\n      // If the additional metas are **NOT** objects or **LACK** enumerable properties\n      // you are going to have a bad time.\n\n      var metalen = metas.length;\n      if (metalen) {\n        for (var i = 0; i < metalen; i++) {\n          Object.assign(info, metas[i]);\n        }\n      }\n      info.message = util.format.apply(util, [msg].concat(_toConsumableArray(splat)));\n      return info;\n    }\n    /**\n      * Transforms the `info` message by using `util.format` to complete\n      * any `info.message` provided it has string interpolation tokens.\n      * If no tokens exist then `info` is immutable.\n      *\n      * @param  {Info} info Logform info message.\n      * @param  {Object} opts Options for this instance.\n      * @returns {Info} Modified info message\n      */\n  }, {\n    key: \"transform\",\n    value: function transform(info) {\n      var msg = info.message;\n      var splat = info[SPLAT] || info.splat; // No need to process anything if splat is undefined\n\n      if (!splat || !splat.length) {\n        return info;\n      } // Extract tokens, if none available default to empty array to\n      // ensure consistancy in expected results\n\n      var tokens = msg && msg.match && msg.match(formatRegExp); // This condition will take care of inputs with info[SPLAT]\n      // but no tokens present\n\n      if (!tokens && (splat || splat.length)) {\n        var metas = splat.length > 1 ? splat.splice(0) : splat; // Now that { splat } has been separated from any potential { meta }. we\n        // can assign this to the `info` object and write it to our format stream.\n        // If the additional metas are **NOT** objects or **LACK** enumerable properties\n        // you are going to have a bad time.\n\n        var metalen = metas.length;\n        if (metalen) {\n          for (var i = 0; i < metalen; i++) {\n            Object.assign(info, metas[i]);\n          }\n        }\n        return info;\n      }\n      if (tokens) {\n        return this._splat(info, tokens);\n      }\n      return info;\n    }\n  }]);\n  return Splatter;\n}();\n/*\n * function splat (info)\n * Returns a new instance of the splat format TransformStream\n * which performs string interpolation from `info` objects. This was\n * previously exposed implicitly in `winston < 3.0.0`.\n */\n\nmodule.exports = function (opts) {\n  return new Splatter(opts);\n};","map":{"version":3,"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","util","require","_require","SPLAT","formatRegExp","escapedPercent","Splatter","opts","options","value","_splat","info","tokens","msg","message","splat","percents","match","escapes","expectedSplat","extraSplat","metas","splice","metalen","assign","format","apply","concat","transform","module","exports"],"sources":["C:/Users/PC/node_modules/firebase-tools/node_modules/logform/dist/splat.js"],"sourcesContent":["'use strict';\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar util = require('util');\n\nvar _require = require('triple-beam'),\n    SPLAT = _require.SPLAT;\n/**\n * Captures the number of format (i.e. %s strings) in a given string.\n * Based on `util.format`, see Node.js source:\n * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230\n * @type {RegExp}\n */\n\n\nvar formatRegExp = /%[scdjifoO%]/g;\n/**\n * Captures the number of escaped % signs in a format string (i.e. %s strings).\n * @type {RegExp}\n */\n\nvar escapedPercent = /%%/g;\n\nvar Splatter =\n/*#__PURE__*/\nfunction () {\n  function Splatter(opts) {\n    _classCallCheck(this, Splatter);\n\n    this.options = opts;\n  }\n  /**\n     * Check to see if tokens <= splat.length, assign { splat, meta } into the\n     * `info` accordingly, and write to this instance.\n     *\n     * @param  {Info} info Logform info message.\n     * @param  {String[]} tokens Set of string interpolation tokens.\n     * @returns {Info} Modified info message\n     * @private\n     */\n\n\n  _createClass(Splatter, [{\n    key: \"_splat\",\n    value: function _splat(info, tokens) {\n      var msg = info.message;\n      var splat = info[SPLAT] || info.splat || [];\n      var percents = msg.match(escapedPercent);\n      var escapes = percents && percents.length || 0; // The expected splat is the number of tokens minus the number of escapes\n      // e.g.\n      // - { expectedSplat: 3 } '%d %s %j'\n      // - { expectedSplat: 5 } '[%s] %d%% %d%% %s %j'\n      //\n      // Any \"meta\" will be arugments in addition to the expected splat size\n      // regardless of type. e.g.\n      //\n      // logger.log('info', '%d%% %s %j', 100, 'wow', { such: 'js' }, { thisIsMeta: true });\n      // would result in splat of four (4), but only three (3) are expected. Therefore:\n      //\n      // extraSplat = 3 - 4 = -1\n      // metas = [100, 'wow', { such: 'js' }, { thisIsMeta: true }].splice(-1, -1 * -1);\n      // splat = [100, 'wow', { such: 'js' }]\n\n      var expectedSplat = tokens.length - escapes;\n      var extraSplat = expectedSplat - splat.length;\n      var metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : []; // Now that { splat } has been separated from any potential { meta }. we\n      // can assign this to the `info` object and write it to our format stream.\n      // If the additional metas are **NOT** objects or **LACK** enumerable properties\n      // you are going to have a bad time.\n\n      var metalen = metas.length;\n\n      if (metalen) {\n        for (var i = 0; i < metalen; i++) {\n          Object.assign(info, metas[i]);\n        }\n      }\n\n      info.message = util.format.apply(util, [msg].concat(_toConsumableArray(splat)));\n      return info;\n    }\n    /**\n      * Transforms the `info` message by using `util.format` to complete\n      * any `info.message` provided it has string interpolation tokens.\n      * If no tokens exist then `info` is immutable.\n      *\n      * @param  {Info} info Logform info message.\n      * @param  {Object} opts Options for this instance.\n      * @returns {Info} Modified info message\n      */\n\n  }, {\n    key: \"transform\",\n    value: function transform(info) {\n      var msg = info.message;\n      var splat = info[SPLAT] || info.splat; // No need to process anything if splat is undefined\n\n      if (!splat || !splat.length) {\n        return info;\n      } // Extract tokens, if none available default to empty array to\n      // ensure consistancy in expected results\n\n\n      var tokens = msg && msg.match && msg.match(formatRegExp); // This condition will take care of inputs with info[SPLAT]\n      // but no tokens present\n\n      if (!tokens && (splat || splat.length)) {\n        var metas = splat.length > 1 ? splat.splice(0) : splat; // Now that { splat } has been separated from any potential { meta }. we\n        // can assign this to the `info` object and write it to our format stream.\n        // If the additional metas are **NOT** objects or **LACK** enumerable properties\n        // you are going to have a bad time.\n\n        var metalen = metas.length;\n\n        if (metalen) {\n          for (var i = 0; i < metalen; i++) {\n            Object.assign(info, metas[i]);\n          }\n        }\n\n        return info;\n      }\n\n      if (tokens) {\n        return this._splat(info, tokens);\n      }\n\n      return info;\n    }\n  }]);\n\n  return Splatter;\n}();\n/*\n * function splat (info)\n * Returns a new instance of the splat format TransformStream\n * which performs string interpolation from `info` objects. This was\n * previously exposed implicitly in `winston < 3.0.0`.\n */\n\n\nmodule.exports = function (opts) {\n  return new Splatter(opts);\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}