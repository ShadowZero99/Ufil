{"ast":null,"code":"'use strict';\n\nmodule.exports = writeFile;\nmodule.exports.sync = writeFileSync;\nmodule.exports._getTmpname = getTmpname; // for testing\nmodule.exports._cleanupOnExit = cleanupOnExit;\nconst fs = require('fs');\nconst MurmurHash3 = require('imurmurhash');\nconst onExit = require('signal-exit');\nconst path = require('path');\nconst isTypedArray = require('is-typedarray');\nconst typedArrayToBuffer = require('typedarray-to-buffer');\nconst {\n  promisify\n} = require('util');\nconst activeFiles = {};\n\n// if we run inside of a worker_thread, `process.pid` is not unique\n/* istanbul ignore next */\nconst threadId = function getId() {\n  try {\n    const workerThreads = require('worker_threads');\n\n    /// if we are in main thread, this is set to `0`\n    return workerThreads.threadId;\n  } catch (e) {\n    // worker_threads are not available, fallback to 0\n    return 0;\n  }\n}();\nlet invocations = 0;\nfunction getTmpname(filename) {\n  return filename + '.' + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();\n}\nfunction cleanupOnExit(tmpfile) {\n  return () => {\n    try {\n      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile);\n    } catch (_) {}\n  };\n}\nfunction serializeActiveFile(absoluteName) {\n  return new Promise(resolve => {\n    // make a queue if it doesn't already exist\n    if (!activeFiles[absoluteName]) activeFiles[absoluteName] = [];\n    activeFiles[absoluteName].push(resolve); // add this job to the queue\n    if (activeFiles[absoluteName].length === 1) resolve(); // kick off the first one\n  });\n}\n\n// https://github.com/isaacs/node-graceful-fs/blob/master/polyfills.js#L315-L342\nfunction isChownErrOk(err) {\n  if (err.code === 'ENOSYS') {\n    return true;\n  }\n  const nonroot = !process.getuid || process.getuid() !== 0;\n  if (nonroot) {\n    if (err.code === 'EINVAL' || err.code === 'EPERM') {\n      return true;\n    }\n  }\n  return false;\n}\nasync function writeFileAsync(filename, data) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (typeof options === 'string') {\n    options = {\n      encoding: options\n    };\n  }\n  let fd;\n  let tmpfile;\n  /* istanbul ignore next -- The closure only gets called when onExit triggers */\n  const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile));\n  const absoluteName = path.resolve(filename);\n  try {\n    await serializeActiveFile(absoluteName);\n    const truename = await promisify(fs.realpath)(filename).catch(() => filename);\n    tmpfile = getTmpname(truename);\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      const stats = await promisify(fs.stat)(truename).catch(() => {});\n      if (stats) {\n        if (options.mode == null) {\n          options.mode = stats.mode;\n        }\n        if (options.chown == null && process.getuid) {\n          options.chown = {\n            uid: stats.uid,\n            gid: stats.gid\n          };\n        }\n      }\n    }\n    fd = await promisify(fs.open)(tmpfile, 'w', options.mode);\n    if (options.tmpfileCreated) {\n      await options.tmpfileCreated(tmpfile);\n    }\n    if (isTypedArray(data)) {\n      data = typedArrayToBuffer(data);\n    }\n    if (Buffer.isBuffer(data)) {\n      await promisify(fs.write)(fd, data, 0, data.length, 0);\n    } else if (data != null) {\n      await promisify(fs.write)(fd, String(data), 0, String(options.encoding || 'utf8'));\n    }\n    if (options.fsync !== false) {\n      await promisify(fs.fsync)(fd);\n    }\n    await promisify(fs.close)(fd);\n    fd = null;\n    if (options.chown) {\n      await promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid).catch(err => {\n        if (!isChownErrOk(err)) {\n          throw err;\n        }\n      });\n    }\n    if (options.mode) {\n      await promisify(fs.chmod)(tmpfile, options.mode).catch(err => {\n        if (!isChownErrOk(err)) {\n          throw err;\n        }\n      });\n    }\n    await promisify(fs.rename)(tmpfile, truename);\n  } finally {\n    if (fd) {\n      await promisify(fs.close)(fd).catch( /* istanbul ignore next */\n      () => {});\n    }\n    removeOnExitHandler();\n    await promisify(fs.unlink)(tmpfile).catch(() => {});\n    activeFiles[absoluteName].shift(); // remove the element added by serializeSameFile\n    if (activeFiles[absoluteName].length > 0) {\n      activeFiles[absoluteName][0](); // start next job if one is pending\n    } else delete activeFiles[absoluteName];\n  }\n}\nfunction writeFile(filename, data, options, callback) {\n  if (options instanceof Function) {\n    callback = options;\n    options = {};\n  }\n  const promise = writeFileAsync(filename, data, options);\n  if (callback) {\n    promise.then(callback, callback);\n  }\n  return promise;\n}\nfunction writeFileSync(filename, data, options) {\n  if (typeof options === 'string') options = {\n    encoding: options\n  };else if (!options) options = {};\n  try {\n    filename = fs.realpathSync(filename);\n  } catch (ex) {\n    // it's ok, it'll happen on a not yet existing file\n  }\n  const tmpfile = getTmpname(filename);\n  if (!options.mode || !options.chown) {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    try {\n      const stats = fs.statSync(filename);\n      options = Object.assign({}, options);\n      if (!options.mode) {\n        options.mode = stats.mode;\n      }\n      if (!options.chown && process.getuid) {\n        options.chown = {\n          uid: stats.uid,\n          gid: stats.gid\n        };\n      }\n    } catch (ex) {\n      // ignore stat errors\n    }\n  }\n  let fd;\n  const cleanup = cleanupOnExit(tmpfile);\n  const removeOnExitHandler = onExit(cleanup);\n  let threw = true;\n  try {\n    fd = fs.openSync(tmpfile, 'w', options.mode || 0o666);\n    if (options.tmpfileCreated) {\n      options.tmpfileCreated(tmpfile);\n    }\n    if (isTypedArray(data)) {\n      data = typedArrayToBuffer(data);\n    }\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0);\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'));\n    }\n    if (options.fsync !== false) {\n      fs.fsyncSync(fd);\n    }\n    fs.closeSync(fd);\n    fd = null;\n    if (options.chown) {\n      try {\n        fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);\n      } catch (err) {\n        if (!isChownErrOk(err)) {\n          throw err;\n        }\n      }\n    }\n    if (options.mode) {\n      try {\n        fs.chmodSync(tmpfile, options.mode);\n      } catch (err) {\n        if (!isChownErrOk(err)) {\n          throw err;\n        }\n      }\n    }\n    fs.renameSync(tmpfile, filename);\n    threw = false;\n  } finally {\n    if (fd) {\n      try {\n        fs.closeSync(fd);\n      } catch (ex) {\n        // ignore close errors at this stage, error may have closed fd already.\n      }\n    }\n    removeOnExitHandler();\n    if (threw) {\n      cleanup();\n    }\n  }\n}","map":{"version":3,"names":["module","exports","writeFile","sync","writeFileSync","_getTmpname","getTmpname","_cleanupOnExit","cleanupOnExit","fs","require","MurmurHash3","onExit","path","isTypedArray","typedArrayToBuffer","promisify","activeFiles","threadId","getId","workerThreads","e","invocations","filename","__filename","hash","String","process","pid","result","tmpfile","unlinkSync","_","serializeActiveFile","absoluteName","Promise","resolve","push","length","isChownErrOk","err","code","nonroot","getuid","writeFileAsync","data","options","encoding","fd","removeOnExitHandler","truename","realpath","catch","mode","chown","stats","stat","uid","gid","open","tmpfileCreated","Buffer","isBuffer","write","fsync","close","chmod","rename","unlink","shift","callback","Function","promise","then","realpathSync","ex","statSync","Object","assign","cleanup","threw","openSync","writeSync","fsyncSync","closeSync","chownSync","chmodSync","renameSync"],"sources":["C:/Users/PC/node_modules/firebase-tools/node_modules/write-file-atomic/index.js"],"sourcesContent":["'use strict'\nmodule.exports = writeFile\nmodule.exports.sync = writeFileSync\nmodule.exports._getTmpname = getTmpname // for testing\nmodule.exports._cleanupOnExit = cleanupOnExit\n\nconst fs = require('fs')\nconst MurmurHash3 = require('imurmurhash')\nconst onExit = require('signal-exit')\nconst path = require('path')\nconst isTypedArray = require('is-typedarray')\nconst typedArrayToBuffer = require('typedarray-to-buffer')\nconst { promisify } = require('util')\nconst activeFiles = {}\n\n// if we run inside of a worker_thread, `process.pid` is not unique\n/* istanbul ignore next */\nconst threadId = (function getId () {\n  try {\n    const workerThreads = require('worker_threads')\n\n    /// if we are in main thread, this is set to `0`\n    return workerThreads.threadId\n  } catch (e) {\n    // worker_threads are not available, fallback to 0\n    return 0\n  }\n})()\n\nlet invocations = 0\nfunction getTmpname (filename) {\n  return filename + '.' +\n    MurmurHash3(__filename)\n      .hash(String(process.pid))\n      .hash(String(threadId))\n      .hash(String(++invocations))\n      .result()\n}\n\nfunction cleanupOnExit (tmpfile) {\n  return () => {\n    try {\n      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile)\n    } catch (_) {}\n  }\n}\n\nfunction serializeActiveFile (absoluteName) {\n  return new Promise(resolve => {\n    // make a queue if it doesn't already exist\n    if (!activeFiles[absoluteName]) activeFiles[absoluteName] = []\n\n    activeFiles[absoluteName].push(resolve) // add this job to the queue\n    if (activeFiles[absoluteName].length === 1) resolve() // kick off the first one\n  })\n}\n\n// https://github.com/isaacs/node-graceful-fs/blob/master/polyfills.js#L315-L342\nfunction isChownErrOk (err) {\n  if (err.code === 'ENOSYS') {\n    return true\n  }\n\n  const nonroot = !process.getuid || process.getuid() !== 0\n  if (nonroot) {\n    if (err.code === 'EINVAL' || err.code === 'EPERM') {\n      return true\n    }\n  }\n\n  return false\n}\n\nasync function writeFileAsync (filename, data, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  let fd\n  let tmpfile\n  /* istanbul ignore next -- The closure only gets called when onExit triggers */\n  const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile))\n  const absoluteName = path.resolve(filename)\n\n  try {\n    await serializeActiveFile(absoluteName)\n    const truename = await promisify(fs.realpath)(filename).catch(() => filename)\n    tmpfile = getTmpname(truename)\n\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      const stats = await promisify(fs.stat)(truename).catch(() => {})\n      if (stats) {\n        if (options.mode == null) {\n          options.mode = stats.mode\n        }\n\n        if (options.chown == null && process.getuid) {\n          options.chown = { uid: stats.uid, gid: stats.gid }\n        }\n      }\n    }\n\n    fd = await promisify(fs.open)(tmpfile, 'w', options.mode)\n    if (options.tmpfileCreated) {\n      await options.tmpfileCreated(tmpfile)\n    }\n    if (isTypedArray(data)) {\n      data = typedArrayToBuffer(data)\n    }\n    if (Buffer.isBuffer(data)) {\n      await promisify(fs.write)(fd, data, 0, data.length, 0)\n    } else if (data != null) {\n      await promisify(fs.write)(fd, String(data), 0, String(options.encoding || 'utf8'))\n    }\n\n    if (options.fsync !== false) {\n      await promisify(fs.fsync)(fd)\n    }\n\n    await promisify(fs.close)(fd)\n    fd = null\n\n    if (options.chown) {\n      await promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid).catch(err => {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      })\n    }\n\n    if (options.mode) {\n      await promisify(fs.chmod)(tmpfile, options.mode).catch(err => {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      })\n    }\n\n    await promisify(fs.rename)(tmpfile, truename)\n  } finally {\n    if (fd) {\n      await promisify(fs.close)(fd).catch(\n        /* istanbul ignore next */\n        () => {}\n      )\n    }\n    removeOnExitHandler()\n    await promisify(fs.unlink)(tmpfile).catch(() => {})\n    activeFiles[absoluteName].shift() // remove the element added by serializeSameFile\n    if (activeFiles[absoluteName].length > 0) {\n      activeFiles[absoluteName][0]() // start next job if one is pending\n    } else delete activeFiles[absoluteName]\n  }\n}\n\nfunction writeFile (filename, data, options, callback) {\n  if (options instanceof Function) {\n    callback = options\n    options = {}\n  }\n\n  const promise = writeFileAsync(filename, data, options)\n  if (callback) {\n    promise.then(callback, callback)\n  }\n\n  return promise\n}\n\nfunction writeFileSync (filename, data, options) {\n  if (typeof options === 'string') options = { encoding: options }\n  else if (!options) options = {}\n  try {\n    filename = fs.realpathSync(filename)\n  } catch (ex) {\n    // it's ok, it'll happen on a not yet existing file\n  }\n  const tmpfile = getTmpname(filename)\n\n  if (!options.mode || !options.chown) {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    try {\n      const stats = fs.statSync(filename)\n      options = Object.assign({}, options)\n      if (!options.mode) {\n        options.mode = stats.mode\n      }\n      if (!options.chown && process.getuid) {\n        options.chown = { uid: stats.uid, gid: stats.gid }\n      }\n    } catch (ex) {\n      // ignore stat errors\n    }\n  }\n\n  let fd\n  const cleanup = cleanupOnExit(tmpfile)\n  const removeOnExitHandler = onExit(cleanup)\n\n  let threw = true\n  try {\n    fd = fs.openSync(tmpfile, 'w', options.mode || 0o666)\n    if (options.tmpfileCreated) {\n      options.tmpfileCreated(tmpfile)\n    }\n    if (isTypedArray(data)) {\n      data = typedArrayToBuffer(data)\n    }\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0)\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'))\n    }\n    if (options.fsync !== false) {\n      fs.fsyncSync(fd)\n    }\n\n    fs.closeSync(fd)\n    fd = null\n\n    if (options.chown) {\n      try {\n        fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)\n      } catch (err) {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      }\n    }\n\n    if (options.mode) {\n      try {\n        fs.chmodSync(tmpfile, options.mode)\n      } catch (err) {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      }\n    }\n\n    fs.renameSync(tmpfile, filename)\n    threw = false\n  } finally {\n    if (fd) {\n      try {\n        fs.closeSync(fd)\n      } catch (ex) {\n        // ignore close errors at this stage, error may have closed fd already.\n      }\n    }\n    removeOnExitHandler()\n    if (threw) {\n      cleanup()\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}