{"ast":null,"code":"'use strict';\n\nconst isObj = require('is-obj');\nconst disallowedKeys = ['__proto__', 'prototype', 'constructor'];\nconst isValidPath = pathSegments => !pathSegments.some(segment => disallowedKeys.includes(segment));\nfunction getPathSegments(path) {\n  const pathArray = path.split('.');\n  const parts = [];\n  for (let i = 0; i < pathArray.length; i++) {\n    let p = pathArray[i];\n    while (p[p.length - 1] === '\\\\' && pathArray[i + 1] !== undefined) {\n      p = p.slice(0, -1) + '.';\n      p += pathArray[++i];\n    }\n    parts.push(p);\n  }\n  if (!isValidPath(parts)) {\n    return [];\n  }\n  return parts;\n}\nmodule.exports = {\n  get(object, path, value) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return value === undefined ? object : value;\n    }\n    const pathArray = getPathSegments(path);\n    if (pathArray.length === 0) {\n      return;\n    }\n    for (let i = 0; i < pathArray.length; i++) {\n      if (!Object.prototype.propertyIsEnumerable.call(object, pathArray[i])) {\n        return value;\n      }\n      object = object[pathArray[i]];\n      if (object === undefined || object === null) {\n        // `object` is either `undefined` or `null` so we want to stop the loop, and\n        // if this is not the last bit of the path, and\n        // if it did't return `undefined`\n        // it would return `null` if `object` is `null`\n        // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n        if (i !== pathArray.length - 1) {\n          return value;\n        }\n        break;\n      }\n    }\n    return object;\n  },\n  set(object, path, value) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return object;\n    }\n    const root = object;\n    const pathArray = getPathSegments(path);\n    for (let i = 0; i < pathArray.length; i++) {\n      const p = pathArray[i];\n      if (!isObj(object[p])) {\n        object[p] = {};\n      }\n      if (i === pathArray.length - 1) {\n        object[p] = value;\n      }\n      object = object[p];\n    }\n    return root;\n  },\n  delete(object, path) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return;\n    }\n    const pathArray = getPathSegments(path);\n    for (let i = 0; i < pathArray.length; i++) {\n      const p = pathArray[i];\n      if (i === pathArray.length - 1) {\n        delete object[p];\n        return;\n      }\n      object = object[p];\n      if (!isObj(object)) {\n        return;\n      }\n    }\n  },\n  has(object, path) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return false;\n    }\n    const pathArray = getPathSegments(path);\n    if (pathArray.length === 0) {\n      return false;\n    }\n\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let i = 0; i < pathArray.length; i++) {\n      if (isObj(object)) {\n        if (!(pathArray[i] in object)) {\n          return false;\n        }\n        object = object[pathArray[i]];\n      } else {\n        return false;\n      }\n    }\n    return true;\n  }\n};","map":{"version":3,"names":["isObj","require","disallowedKeys","isValidPath","pathSegments","some","segment","includes","getPathSegments","path","pathArray","split","parts","i","length","p","undefined","slice","push","module","exports","get","object","value","Object","prototype","propertyIsEnumerable","call","set","root","delete","has"],"sources":["C:/Users/PC/node_modules/firebase-tools/node_modules/configstore/node_modules/dot-prop/index.js"],"sourcesContent":["'use strict';\nconst isObj = require('is-obj');\n\nconst disallowedKeys = [\n\t'__proto__',\n\t'prototype',\n\t'constructor'\n];\n\nconst isValidPath = pathSegments => !pathSegments.some(segment => disallowedKeys.includes(segment));\n\nfunction getPathSegments(path) {\n\tconst pathArray = path.split('.');\n\tconst parts = [];\n\n\tfor (let i = 0; i < pathArray.length; i++) {\n\t\tlet p = pathArray[i];\n\n\t\twhile (p[p.length - 1] === '\\\\' && pathArray[i + 1] !== undefined) {\n\t\t\tp = p.slice(0, -1) + '.';\n\t\t\tp += pathArray[++i];\n\t\t}\n\n\t\tparts.push(p);\n\t}\n\n\tif (!isValidPath(parts)) {\n\t\treturn [];\n\t}\n\n\treturn parts;\n}\n\nmodule.exports = {\n\tget(object, path, value) {\n\t\tif (!isObj(object) || typeof path !== 'string') {\n\t\t\treturn value === undefined ? object : value;\n\t\t}\n\n\t\tconst pathArray = getPathSegments(path);\n\t\tif (pathArray.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < pathArray.length; i++) {\n\t\t\tif (!Object.prototype.propertyIsEnumerable.call(object, pathArray[i])) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tobject = object[pathArray[i]];\n\n\t\t\tif (object === undefined || object === null) {\n\t\t\t\t// `object` is either `undefined` or `null` so we want to stop the loop, and\n\t\t\t\t// if this is not the last bit of the path, and\n\t\t\t\t// if it did't return `undefined`\n\t\t\t\t// it would return `null` if `object` is `null`\n\t\t\t\t// but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n\t\t\t\tif (i !== pathArray.length - 1) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn object;\n\t},\n\n\tset(object, path, value) {\n\t\tif (!isObj(object) || typeof path !== 'string') {\n\t\t\treturn object;\n\t\t}\n\n\t\tconst root = object;\n\t\tconst pathArray = getPathSegments(path);\n\n\t\tfor (let i = 0; i < pathArray.length; i++) {\n\t\t\tconst p = pathArray[i];\n\n\t\t\tif (!isObj(object[p])) {\n\t\t\t\tobject[p] = {};\n\t\t\t}\n\n\t\t\tif (i === pathArray.length - 1) {\n\t\t\t\tobject[p] = value;\n\t\t\t}\n\n\t\t\tobject = object[p];\n\t\t}\n\n\t\treturn root;\n\t},\n\n\tdelete(object, path) {\n\t\tif (!isObj(object) || typeof path !== 'string') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst pathArray = getPathSegments(path);\n\n\t\tfor (let i = 0; i < pathArray.length; i++) {\n\t\t\tconst p = pathArray[i];\n\n\t\t\tif (i === pathArray.length - 1) {\n\t\t\t\tdelete object[p];\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tobject = object[p];\n\n\t\t\tif (!isObj(object)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t},\n\n\thas(object, path) {\n\t\tif (!isObj(object) || typeof path !== 'string') {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst pathArray = getPathSegments(path);\n\t\tif (pathArray.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// eslint-disable-next-line unicorn/no-for-loop\n\t\tfor (let i = 0; i < pathArray.length; i++) {\n\t\t\tif (isObj(object)) {\n\t\t\t\tif (!(pathArray[i] in object)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tobject = object[pathArray[i]];\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}