{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.logger = void 0;\nvar winston = require(\"winston\");\nfunction expandErrors(logger) {\n  var oldLogFunc = logger.log.bind(logger);\n  var newLogFunc = function newLogFunc(levelOrEntry, message) {\n    for (var _len = arguments.length, meta = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      meta[_key - 2] = arguments[_key];\n    }\n    if (message && message instanceof Error) {\n      message = message.stack || message.message;\n      return oldLogFunc.apply(void 0, [levelOrEntry, message].concat(meta));\n    }\n    return oldLogFunc.apply(void 0, [levelOrEntry, message].concat(meta));\n  };\n  logger.log = newLogFunc;\n  return logger;\n}\nfunction annotateDebugLines(logger) {\n  var debug = logger.debug.bind(logger);\n  var newDebug = function newDebug(message) {\n    if (typeof message === \"string\") {\n      message = \"[\".concat(new Date().toISOString(), \"] \").concat(message || \"\");\n    }\n    for (var _len2 = arguments.length, meta = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      meta[_key2 - 1] = arguments[_key2];\n    }\n    return debug.apply(void 0, [message].concat(meta));\n  };\n  logger.debug = newDebug;\n  return logger;\n}\nvar rawLogger = winston.createLogger();\nrawLogger.add(new winston.transports.Console({\n  silent: true\n}));\nrawLogger.exitOnError = false;\nexports.logger = annotateDebugLines(expandErrors(rawLogger));","map":null,"metadata":{},"sourceType":"script"}