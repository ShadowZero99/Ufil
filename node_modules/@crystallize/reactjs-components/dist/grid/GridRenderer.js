"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GridRenderer = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const CSSGrid_1 = require("./CSSGrid");
const grid_renderer_utils_1 = require("./grid-renderer-utils");
const RowCol_1 = require("./RowCol");
const Table_1 = require("./Table");
const types_1 = require("./types");
const GridRenderer = ({ cellComponent, children, grid, type = types_1.GridRenderingType.Div, styleForCell, ...props }) => {
    if (!cellComponent && !children) {
        console.error('@crystallize/grid-renderer: missing Â´cellComponent` or children function');
        return null;
    }
    if (!grid.rows.length)
        return null;
    const dimensions = (0, grid_renderer_utils_1.getGridDimensions)(grid.rows);
    if (type === types_1.GridRenderingType.Table) {
        return ((0, jsx_runtime_1.jsx)(Table_1.Table, { cellComponent: cellComponent, grid: grid.rows, dimensions: dimensions, styleForCell: styleForCell, ...props, children: children }));
    }
    if (type === types_1.GridRenderingType.RowCol) {
        return ((0, jsx_runtime_1.jsx)(RowCol_1.RowCol, { cellComponent: cellComponent, grid: grid.rows, dimensions: dimensions, styleForCell: styleForCell, ...props, children: children }));
    }
    const cells = grid.rows.reduce((memo, row) => memo.concat(row.columns), []);
    return ((0, jsx_runtime_1.jsx)(CSSGrid_1.CSSGrid, { cellComponent: cellComponent, cells: cells, dimensions: dimensions, styleForCell: styleForCell, ...props, children: children }));
};
exports.GridRenderer = GridRenderer;
//# sourceMappingURL=GridRenderer.js.map