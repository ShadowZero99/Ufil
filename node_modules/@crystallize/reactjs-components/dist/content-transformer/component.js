"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentTransformer = exports.ContentTransformerNode = exports.renderTextContent = exports.NodeContent = exports.OverridesContext = exports.Renderers = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
exports.Renderers = {
    link: (props) => ((0, jsx_runtime_1.jsx)("a", { href: props.metadata?.href, children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) })),
    'unordered-list': (props) => ((0, jsx_runtime_1.jsx)("ul", { children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) })),
    'ordered-list': (props) => ((0, jsx_runtime_1.jsx)("ol", { children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) })),
    list: (props) => ((0, jsx_runtime_1.jsx)("ul", { children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) })),
    'list-item': (props) => ((0, jsx_runtime_1.jsx)("li", { children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) })),
    quote: (props) => {
        if (props.kind === 'block') {
            return ((0, jsx_runtime_1.jsx)("blockquote", { children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) }));
        }
        return ((0, jsx_runtime_1.jsx)("q", { children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) }));
    },
    paragraph: (props) => ((0, jsx_runtime_1.jsx)("p", { children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) })),
    preformatted: (props) => ((0, jsx_runtime_1.jsx)("pre", { children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) })),
    code: (props) => ((0, jsx_runtime_1.jsx)("code", { children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) })),
    underlined: (props) => ((0, jsx_runtime_1.jsx)("u", { children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) })),
    strong: (props) => ((0, jsx_runtime_1.jsx)("strong", { children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) })),
    emphasized: (props) => ((0, jsx_runtime_1.jsx)("em", { children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) })),
    div: (props) => ((0, jsx_runtime_1.jsx)("div", { children: (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }) })),
    span: (props) => (0, jsx_runtime_1.jsx)(exports.NodeContent, { ...props }),
    'line-break': () => (0, jsx_runtime_1.jsx)("br", {}),
};
exports.OverridesContext = (0, react_1.createContext)(null);
const NodeContent = (props) => {
    const { textContent } = props;
    if (textContent) {
        return renderTextContent(textContent);
    }
    if (props.children) {
        return ((0, jsx_runtime_1.jsx)(react_1.Fragment, { children: props.children.map((child, i) => ((0, jsx_runtime_1.jsx)(exports.ContentTransformerNode, { ...child }, i))) }));
    }
    return null;
};
exports.NodeContent = NodeContent;
// Render text and convert line breaks (\n) to <br />
function renderTextContent(text) {
    const partsBetweenLineBreaks = text.split(/\n/g);
    if (partsBetweenLineBreaks.length === 1) {
        return (0, jsx_runtime_1.jsx)(react_1.Fragment, { children: text });
    }
    return ((0, jsx_runtime_1.jsx)(react_1.Fragment, { children: partsBetweenLineBreaks.map((part, index) => {
            const key = index.toString();
            if (index === partsBetweenLineBreaks.length - 1) {
                return (0, jsx_runtime_1.jsx)(react_1.Fragment, { children: "part" }, key);
            }
            return ((0, jsx_runtime_1.jsxs)(react_1.Fragment, { children: [part, (0, jsx_runtime_1.jsx)("br", {})] }, key));
        }) }));
}
exports.renderTextContent = renderTextContent;
const ContentTransformerNode = (props) => {
    let Renderer = exports.Renderers.span;
    const overrides = (0, react_1.useContext)(exports.OverridesContext);
    const { type, kind, textContent } = props;
    if (type) {
        const t = type;
        const override = overrides?.[t];
        Renderer = override || exports.Renderers[type];
    }
    if (!Renderer) {
        Renderer = exports.Renderers.span;
        if (type === 'container' && kind === 'block') {
            Renderer = exports.Renderers.div;
        }
        else if (type === null && textContent) {
            return renderTextContent(textContent);
        }
    }
    return (0, jsx_runtime_1.jsx)(Renderer, { ...props });
};
exports.ContentTransformerNode = ContentTransformerNode;
const ContentTransformer = ({ overrides = null, json }) => {
    if (!json) {
        return null;
    }
    if (Array.isArray(json)) {
        const nodes = json;
        return ((0, jsx_runtime_1.jsx)(exports.OverridesContext.Provider, { value: overrides, children: nodes.map((j, i) => ((0, jsx_runtime_1.jsx)(exports.ContentTransformerNode, { ...j }, i))) }));
    }
    const node = json;
    return ((0, jsx_runtime_1.jsx)(exports.OverridesContext.Provider, { value: overrides, children: (0, jsx_runtime_1.jsx)(exports.ContentTransformerNode, { ...node }) }));
};
exports.ContentTransformer = ContentTransformer;
//# sourceMappingURL=component.js.map