"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProductHydrater = void 0;
const json_to_graphql_query_1 = require("json-to-graphql-query");
function byPaths(client) {
    return (paths, language, extraQuery, perProduct, perVariant) => {
        const productListQuery = paths.reduce((acc, path, index) => {
            acc[`product${index}`] = {
                __aliasFor: 'catalogue',
                __args: { path, language },
                name: true,
                path: true,
                __on: {
                    __typeName: 'Product',
                    vatType: {
                        name: true,
                        percent: true,
                    },
                    variants: {
                        sku: true,
                        name: true,
                        attributes: {
                            attribute: true,
                            value: true,
                        },
                        priceVariants: {
                            name: true,
                            price: true,
                            identifier: true,
                            currency: true,
                        },
                        ...(perVariant !== undefined ? perVariant(path, index) : {}),
                    },
                    ...(perProduct !== undefined ? perProduct(path, index) : {}),
                },
            };
            return acc;
        }, {});
        const query = {
            ...{ ...productListQuery },
            ...(extraQuery !== undefined ? extraQuery : {}),
        };
        const fetch = client.catalogueApi;
        return fetch((0, json_to_graphql_query_1.jsonToGraphQLQuery)({ query }));
    };
}
function bySkus(client) {
    async function getPathForSkus(skus, language) {
        const search = client.searchApi;
        const pathsSet = new Set();
        let searchAfterCursor;
        async function getNextSearchPage() {
            const searchAPIResponse = await search(`query GET_PRODUCTS_BY_SKU ($skus: [String!], $after: String, $language: String!) {
                    search (
                        after: $after
                        language: $language
                        filter: {
                            include: {
                                skus: $skus
                            }
                        }
                    ) {
                        pageInfo {
                            endCursor
                            hasNextPage
                        }
                        edges {
                            node {
                                path
                            }
                        }
                    }
                }`, {
                skus: skus,
                after: searchAfterCursor,
                language,
            });
            const { edges, pageInfo } = searchAPIResponse.search || {};
            edges?.forEach((edge) => pathsSet.add(edge.node.path));
            if (pageInfo?.hasNextPage) {
                searchAfterCursor = pageInfo.endCursor;
                await getNextSearchPage();
            }
        }
        await getNextSearchPage();
        return Array.from(pathsSet);
    }
    return async (skus, language, extraQuery, perProduct, perVariant) => {
        const paths = await getPathForSkus(skus, language);
        if (paths.length === 0) {
            const empty = skus.reduce((acc, sku, index) => {
                acc[`product${index}`] = {};
                return acc;
            }, {});
            return empty;
        }
        return byPaths(client)(paths, language, extraQuery, perProduct, perVariant);
    };
}
function createProductHydrater(client) {
    return {
        byPaths: byPaths(client),
        bySkus: bySkus(client),
    };
}
exports.createProductHydrater = createProductHydrater;
//# sourceMappingURL=hydrate.js.map