"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createClient = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
function authenticationHeaders(config) {
    if (config.sessionId) {
        return {
            Cookie: 'connect.sid=' + config.sessionId,
        };
    }
    if (config.staticAuthToken) {
        return {
            'X-Crystallize-Static-Auth-Token': config.staticAuthToken,
        };
    }
    return {
        'X-Crystallize-Access-Token-Id': config.accessTokenId || '',
        'X-Crystallize-Access-Token-Secret': config.accessTokenSecret || '',
    };
}
async function post(path, config, query, variables, init) {
    try {
        const commonHeaders = {
            'Content-type': 'application/json; charset=UTF-8',
            Accept: 'application/json',
        };
        const headers = {
            ...commonHeaders,
            ...authenticationHeaders(config),
        };
        const body = JSON.stringify({ query, variables });
        const response = await (0, node_fetch_1.default)(path, {
            ...init,
            method: 'POST',
            headers,
            body,
        });
        if (response.ok && 204 === response.status) {
            return {};
        }
        if (!response.ok) {
            const json = await response.json();
            throw {
                code: response.status,
                statusText: response.statusText,
                message: json.message,
                errors: json.errors || {},
            };
        }
        // we still need to check for error as the API can return 200 with errors
        const json = await response.json();
        if (json.errors) {
            throw {
                code: 400,
                statusText: 'Error was returned from the API',
                message: json.errors[0].message,
                errors: json.errors || {},
            };
        }
        return json.data;
    }
    catch (exception) {
        throw exception;
    }
}
function createApiCaller(uri, configuration) {
    /**
     * Call a crystallize. Will automatically handle access tokens
     * @param query The GraphQL query
     * @param variables Variables to inject into query.
     */
    return function callApi(query, variables) {
        return post(uri, configuration, query, variables);
    };
}
/**
 * Create one api client for each api endpoint Crystallize offers (catalogue, search, order, subscription, pim).
 *
 * @param configuration
 * @returns ClientInterface
 */
function createClient(configuration) {
    const identifier = configuration.tenantIdentifier;
    const origin = configuration.origin || '.crystallize.com';
    const apiHost = (path, prefix = 'api') => `https://${prefix}${origin}/${path.join('/')}`;
    return {
        catalogueApi: createApiCaller(apiHost([identifier, 'catalogue']), configuration),
        searchApi: createApiCaller(apiHost([identifier, 'search']), configuration),
        orderApi: createApiCaller(apiHost([identifier, 'orders']), configuration),
        subscriptionApi: createApiCaller(apiHost([identifier, 'subscriptions']), configuration),
        pimApi: createApiCaller(apiHost(['graphql'], 'pim'), configuration),
        config: {
            tenantId: configuration.tenantId,
            tenantIdentifier: configuration.tenantIdentifier,
            origin: configuration.origin,
        },
    };
}
exports.createClient = createClient;
//# sourceMappingURL=client.js.map